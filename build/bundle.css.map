{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../SvelteTable.svelte",
    "../../App.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { createEventDispatcher } from 'svelte';\n\n  const dispatch = createEventDispatcher();\n\n  export let columns;\n  export let rows;\n  export let sortBy = \"\";\n  export let sortOrder = 1;\n  export let iconAsc = '▲';\n  export let iconDesc = '▼';\n  export let classNameTable = '';\n  export let classNameThead = '';\n  export let classNameTbody = '';\n  export let classNameSelect = '';\n  export let classNameRow = '';\n  export let classNameCell = '';\n\n  let sortFunction = () => \"\";\n  let showFilterHeader = columns.some(c => c.filterOptions !== undefined);\n  let filterValues = {};\n  let filterSettings = {};\n  let columnByKey = {};\n  columns.forEach(col => {\n    columnByKey[col.key] = col;\n  });\n\n  $: c_rows = rows\n    .filter(r =>\n    Object.keys(filterSettings).every(f => {\n    let ret =  (\n          filterSettings[f] === undefined ||\n          // default to value() if filterValue() not provided in col\n          filterSettings[f] === (typeof columnByKey[f].filterValue === 'function' ? \n            columnByKey[f].filterValue(r) : columnByKey[f].value(r))\n        );\n        return ret;\n    })\n    )\n    .map(r => (Object.assign({}, r, {$sortOn: sortFunction(r)} ) ) )\n    .sort((a, b) => {\n    if (a.$sortOn > b.$sortOn) return sortOrder;\n    else if (a.$sortOn < b.$sortOn) return -sortOrder;\n    return 0;\n    });\n\n  const asStringArray = (v) => [].concat(v).filter(v => typeof v === 'string' && v !== \"\").join(' ');\n\n  const calculateFilterValues = () => {\n    filterValues = {};\n    columns.forEach(c => {\n    if (typeof c.filterOptions === \"function\") {\n        filterValues[c.key] = c.filterOptions(rows);\n    } else if (Array.isArray(c.filterOptions)) {\n        // if array of strings is provided, use it for name and value\n        filterValues[c.key] = c.filterOptions.map(val => ({name:val, value:val}));\n    }\n    });\n  };\n\n\n  $: {\n    let col = columnByKey[sortBy];\n    if (col !== undefined && col.sortable === true && typeof col.value === \"function\") {\n    sortFunction = r => col.value(r);\n    }\n  };\n\n  const updateSortOrder = (colKey) => {\n    if (colKey === sortBy) {\n      sortOrder = sortOrder === 1 ? -1 : 1\n    } else {\n      sortOrder = 1;\n    }\n  }\n  \n  const handleClickCol = (col) => {\n    updateSortOrder(col.key)\n    sortBy = col.key;\n    dispatch('clickCol', {key:col.key} );\n  }\n  \n  const handleClickRow = (row) => {\n    dispatch('clickRow', {row} );\n  }\n\n  const handleClickCell = (row, key) => {\n    dispatch('clickCell', {row, key} );\n  }\n\n  if (showFilterHeader) {\n    calculateFilterValues();\n  }\n</script>\n\n<style>\n  table {\n    width: 100%;\n  }\n  .isSortable {\n    cursor: pointer;\n  }\n\n  tr th select {\n    width: 100%;\n  }\n</style>\n\n<table class={asStringArray(classNameTable)}>\n  <thead class={asStringArray(classNameThead)}>\n    {#if showFilterHeader}\n      <tr>\n        {#each columns as col}\n          <th>\n            {#if filterValues[col.key] !== undefined}\n              <select bind:value={filterSettings[col.key]} class={asStringArray(classNameSelect)}>\n                <option value={undefined}></option>\n                {#each filterValues[col.key] as option}\n                  <option value={option.value}>{option.name}</option>\n                {/each}\n              </select>\n            {/if}\n          </th>\n        {/each}\n      </tr>\n    {/if}\n      <slot name=\"header\" sortOrder={sortOrder} sortBy={sortBy}>\n        <tr>\n          {#each columns as col}\n            <th\n              on:click={() => handleClickCol(col)}\n              class={asStringArray([col.sortable ? 'isSortable' : null, col.headerClass])}\n            >\n              {col.title}\n              {#if sortBy === col.key}\n                { sortOrder === 1 ? iconAsc : iconDesc}\n              {/if}\n            </th>\n          {/each}\n        </tr>\n      </slot>\n  </thead>\n  <tbody class={asStringArray(classNameTbody)}>\n    {#each c_rows as row, n}\n      <slot name=\"row\" row={row} n={n} >\n        <tr on:click={()=>{handleClickRow(row)}} class={asStringArray(classNameRow)}>\n          {#each columns as col}\n            <td\n              on:click={()=>{handleClickCell(row, col.key)}}\n              class={asStringArray([col.class, classNameCell])}\n            >{@html col.renderValue ? col.renderValue(row) : col.value(row)}</td>\n          {/each}\n        </tr>\n      </slot>\n    {/each}\n  </tbody>\n</table>\n",
    "<script>\nimport SvelteTable from \"svelte-table\";\nimport { onMount } from 'svelte';\n\n// export const wordCountAll = \"23,349,745\";\n// export const nodeCountAll = \"227,676\";\n\nlet rows = [];\nlet wordCountAll = \"\";\nlet nodeCountAll = \"\";\nconst scaifebase = \"Read in Scaife\";\n\nonMount(async () => {\n\t\tconst res = await fetch(`https://raw.githubusercontent.com/OpenGreekAndLatin/First1KGreek/gh-pages/build/catalog.json`);\n    const response = await res.json();\n    rows = response['catalog']\n    wordCountAll = response.greekWords.toLocaleString()\n    nodeCountAll = response.nodeCount.toLocaleString()\n\t});\n\nconst columns = [\n  {\n    key: \"group_name\",\n    title: \"Workgroup\",\n    value: v => v.group_name,\n    sortable: true\n  },\n  {\n    key: \"work_name\",\n    title: \"Work\",\n    value: v => v.work_name,\n    sortable: true\n  },\n  {\n    key: \"language\",\n    title: \"Language\",\n    value: v => v.language,\n    sortable: false\n  },\n  {\n    key: \"scaife\",\n    title: \"Read\",\n    value: v => scaifebase.link(v.scaife),\n    sortable: false,\n    headerClass: \"text-left\"\n  },\n  {\n    key: \"wordcount\",\n    title: \"Words\",\n    value: v => v.wordcount,\n    sortable: true,\n    headerClass: \"text-left\"\n  },\n  {\n    key: \"urn\",\n    title: \"URN\",\n    value: v => v.urn,\n    sortable: true,\n    headerClass: \"text-left\"\n  }\n];\n\nfunction handleZip() {\n\twindow.location.assign(\"https://github.com/OpenGreekAndLatin/First1KGreek/zipball/master\");\n};\n\nfunction handleTar() {\n\twindow.location.assign(\"https://github.com/OpenGreekAndLatin/First1KGreek/tarball/master\");\n};\n\nfunction handleGit() {\n\twindow.open(\"https://github.com/OpenGreekAndLatin/First1KGreek\");\n};\n  \n</script>\n\n<main>\n\t<h1>Welcome to the <a href=\"http://www.opengreekandlatin.org\">First1KGreek Project</a>!</h1>\t\n\t<p>The goal of this project is to collect at least one edition of every Greek work composed between Homer and 250CE with a focus on texts that do not already exist in the Perseus Digital Library. So, e.g., neither Thucydides nor the text of the New Testament are here because both of these texts are already in <a href = \"http://www.perseus.tufts.edu/hopper/\">Perseus</a>. The TEI XML versions of the Perseus Greek texts (c. 10 million words) are available at <a href = \"https://github.com/PerseusDL/canonical-greekLit\">GitHub</a>, where they are being revised (upgrading to epiDoc compliant P5 TEI XML) and reorganized to be more readily CTS compliant. This project has been generously funded by the Harvard Library Arcadia Fund, European Social Fund, and the Alexander-von-Humboldt professorship for Digital Humanities at Leipzig. The data has been produced in an international cooperation with the Center for Hellenic Studies, the Harvard Library, Mount Alison University, Tufts University, the University of Leipzig, and the University of Virginia.</p>\n\n<p>All the works in the repository for which we have added metadata are listed below with links to the individual files. Note that all of these files are 100% CTS-compliant. If you see any problems with this list, please start an issue on the <a href=\"https://github.com/OpenGreekAndLatin/First1KGreek/issues\">main repository page</a>. At this time, the repository contains <strong>{wordCountAll}</strong> words in <strong>{nodeCountAll}</strong> CTS-nodes. The text is primarily in Greek, with more texts currently being corrected and converted to epiDoc-compliant TEI XML. When these remaining texts and the Perseus collection are added, the amount of CC-licensed TEI XML Greek available on GitHub will exceed 30 million words.</p>\n\n<p>The list below also includes the unique identifiers that we use for every author, work, and edition. We use standard identifiers to name our texts, including references to the numbers adopted by the canons of the TLG and (for Latin) PHI. The final element in the URN identifies the edition. See the TEI headers of the individual files to find all information about the origin of the file.</p>\n\n<p>The list as well as node and word counts were generated using <a href=\"https://github.com/ThomasK81/TEItoCEX\">TEItoCEX</a> by Thomas Koentges. You can also use the download buttons to access the data.</p>\n\t<button on:click={handleZip}>\n\t\tZip-file\n\t</button>\n\t<button on:click={handleTar}>\n\t\tTar-ball\n\t</button>\n\t<button on:click={handleGit}>\n\t\tGithub\n\t</button>\n\t<SvelteTable columns=\"{columns}\" rows=\"{rows}\"></SvelteTable>\n</main>\n\n<style>\n\tmain {\n\t\ttext-align: center;\n\t\tpadding: 1em;\n\t\tmax-wurnth: 240px;\n\t\tmargin: 0 auto;\n\t}\n\n\th1 {\n\t\tcolor: rgb(80,0,80);\n\t\tfont-size: 4em;\n\t\tfont-weight: 100;\n\t}\n\n\tp {\n\t\ttext-align: left;\n\t}\n\n\t@media (min-wurnth: 640px) {\n\t\tmain {\n\t\t\tmax-wurnth: none;\n\t\t}\n\t}\n</style>"
  ],
  "names": [],
  "mappings": "AAgGE,KAAK,4BAAC,CAAC,AACL,KAAK,CAAE,IAAI,AACb,CAAC,AACD,WAAW,4BAAC,CAAC,AACX,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,gBAAE,CAAC,EAAE,CAAC,MAAM,cAAC,CAAC,AACZ,KAAK,CAAE,IAAI,AACb,CAAC;ACPF,IAAI,eAAC,CAAC,AACL,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CACZ,UAAU,CAAE,KAAK,CACjB,MAAM,CAAE,CAAC,CAAC,IAAI,AACf,CAAC,AAED,EAAE,eAAC,CAAC,AACH,KAAK,CAAE,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CACnB,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,AACjB,CAAC,AAED,CAAC,eAAC,CAAC,AACF,UAAU,CAAE,IAAI,AACjB,CAAC,AAED,MAAM,AAAC,aAAa,KAAK,CAAC,AAAC,CAAC,AAC3B,IAAI,eAAC,CAAC,AACL,UAAU,CAAE,IAAI,AACjB,CAAC,AACF,CAAC"
}